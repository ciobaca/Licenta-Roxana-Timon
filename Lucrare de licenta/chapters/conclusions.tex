\chapter*{Concluzii} 
\addcontentsline{toc}{chapter}{Concluzii}
În cadrul acestei lucrări de licență, am explorat și demonstrat în Dafny corectitudinea algoritmului de selecție a activităților cu profit maxim, utilizând programare dinamică. Prin intermediul limbajului imperativ Dafny, am reușit să implementez algoritmul și să verific formal corectitudinea acestuia.
 
Utilizarea Dafny a fost esențială pentru a garanta că implementarea respectă toate cerințele de corectitudine, prin verificarea semiautomată a invarianților și a proprietăților specificate.
Rezultatele obținute au confirmat faptul că algoritmul este corect.

\section{Statistici}
Implementarea este structurată într-un singur script:
\begin{table}[h!]
  \centering
  \begin{tabular}{lcr} % l = left, c = center, r = right
    \toprule
    Nume & Număr de linii  & Scop \\
    \midrule
    day.dfy  & 928  & Verificarea algoritmului   \\
    \bottomrule
  \end{tabular}
  \label{tab:table1}
\end{table}

Liniile de cod de mai sus, includ specificații, leme, assert-uri ajutătoare, comentarii și linii de delimitare. Dezvoltarea conține un total de 34 metode, leme, funcții și predicate de verificat. Verificarea durează aproximativ 8 secunde pe un calculator modern (2.60GHz 11th Gen Intel(R) Core(TM) i5-1145G7, 16 GB) cu un singur fir de execuție. 

Iată timpii de verificare pentru metodele, lemele și predicatele folosite la verificarea algoritmului:

\begin{longtable}{|l|r|}
\caption{Timpii de verificare}\\
\hline
\textbf{Verificare} & \textbf{Timp (s)} \\
\hline
\endfirsthead
\hline
\textbf{Verificare} & \textbf{Timp (s)} \\
\hline
\endhead
\hline
\endfoot

Running abstract interpretation & 0.0605648 \\
validProblem & 0.115 \\
distinctJobsSeq & 0.033 \\
sortedByActEnd & 0.037 \\
hasNoOverlappingJobs & 0.039 \\
PartialSolProfit & 0.042 \\
isPartialSol & 0.044 \\
isOptParSol & 0.051 \\
HasProfit & 0.056 \\
isOptParSolDP & 0.051 \\
OptParSolutions & 0.055 \\
isSolution & 0.048 \\
isOptimalSolution & 0.047 \\
containsOnlyZeros & 0.031 \\
partialSolutionWithJobI & 0.041 \\
partialSolutionWithoutJobI & 0.045 \\
HasLessProf & 0.041 \\
HasMoreProfit & 0.036 \\
ProfitParSolStartFinishPos & 0.037 \\
AssociativityOfProfitFunc (well-formedness) & 0.061 \\
AssociativityOfProfitFunc (correctness) & 0.049 \\
EqOfProfitFuncFromIndToEnd (well-formedness) & 0.038 \\
EqOfProfitFuncFromIndToEnd (correctness) & 0.040 \\
EqOfProfFuncUntilIndex (well-formedness) & 0.036 \\
EqOfProfFuncUntilIndex (correctness) & 0.047 \\
SplitSequenceProfitEquality (well-formedness) & 0.034 \\
SplitSequenceProfitEquality (correctness) & 0.425 \\
ProfitLastElem (well-formedness) & 0.041 \\
ProfitLastElem (correctness) & 0.043 \\
ComputeProfitWhenOnly0BetweenJI (well-formedness) & 0.043 \\
ComputeProfitWhenOnly0BetweenJI (correctness) & 2.988 \\
HasMoreProfThanOptParSol (well-formedness) & 0.046 \\
HasMoreProfThanOptParSol (correctness) & 0.047 \\
OtherSolHasLessProfThenMaxProfit2 (well-formedness) & 0.096 \\
OtherSolHasLessProfThenMaxProfit2 (correctness) & 0.190 \\
OnlY0WhenOverlapJobs (well-formedness) & 0.045 \\
OnlY0WhenOverlapJobs (correctness) & 0.045 \\
OptParSolWhenNonOverlapJob (well-formedness) & 0.067 \\
OptParSolWhenNonOverlapJob (correctness) & 0.321 \\
OtherSolHasLessProfThenMaxProfit (well-formedness) & 0.044 \\
OtherSolHasLessProfThenMaxProfit (correctness) & 0.059 \\
OptParSolWhenOverlapJob (well-formedness) & 0.080 \\
OptParSolWhenOverlapJob (correctness) & 0.392 \\
MaxProfitWithJobI (well-formedness) & 0.056 \\
MaxProfitWithJobI (correctness) & 0.135 \\
NotAddingAJobKeepsSameProfit (well-formedness) & 0.039 \\
NotAddingAJobKeepsSameProfit (correctness) & 0.093 \\
SubSeqOfPartialIsAlsoPartial (well-formedness) & 0.039 \\
SubSeqOfPartialIsAlsoPartial (correctness) & 0.040 \\
optimalPartialSolutionWithJobI (well-formedness) & 0.055 \\
optimalPartialSolutionWithJobI (correctness) & 0.158 \\
leadsToOptWithJobI (well-formedness) & 0.081 \\
leadsToOptWithJobI (correctness) & 0.117 \\
optimalPartialSolutionWithoutJobI (well-formedness) & 0.052 \\
optimalPartialSolutionWithoutJobI (correctness) & 0.122 \\
leadsToOptWithoutJobI (well-formedness) & 0.085 \\
leadsToOptWithoutJobI (correctness) & 0.107 \\
WeightedJobScheduling (well-formedness) & 0.062 \\
WeightedJobScheduling (correctness) & 0.268 \\
Main (correctness) & 0.068 \\
\hline
\textbf{Total} & \textbf{7.9045648} \\
\hline

\end{longtable}

Putem observa că timpul de verificare este foarte bun, valoarea cea mai mare  fiind 2 secunde în cazul lemei \texttt{ComputeProfitWhenOnly0BetweenJI}.
Această lema demonstrează pentru o soluție parțială care conține activitatea de pe poziția \texttt{i}, că profitul de la poziția \texttt{j + 1} până la poziția \texttt{i} este \texttt{jobs[i].profit}, știind că nicio activitate nu a fost selectată pe aceste poziții (avem doar 0-uri).

\begin{Verbatim}[commandchars=\\\{\}, fontsize=\footnotesize]
\PY{k+kd}{lemma} \PY{n+nf}{ComputeProfitWhenOnly0BetweenJI}\PY{p}{(}\PY{n}{partialSol}\PY{p}{:} \PY{k+kt}{seq}\PY{o}{\PYZlt{}}\PY{k+kt}{int}\PY{o}{\PYZgt{}}\PY{p}{,} \PY{n}{jobs}\PY{p}{:} \PY{k+kt}{seq}\PY{o}{\PYZlt{}}\PY{n}{Job}\PY{o}{\PYZgt{}}\PY{p}{,} \PY{n}{i}\PY{p}{:} \PY{k+kt}{int}\PY{p}{,}
\PY{n}{j}\PY{p}{:} \PY{k+kt}{int}\PY{p}{)}
  \PY{k}{requires} \PY{n}{validJobsSeq}\PY{p}{(}\PY{n}{jobs}\PY{p}{)}
  \PY{k}{requires} \PY{l+m+mi}{0} \PY{o}{\PYZlt{}=} \PY{n}{j} \PY{o}{\PYZlt{}} \PY{n}{i} \PY{o}{\PYZlt{}} \PY{o}{|}\PY{n}{partialSol}\PY{o}{|} \PY{o}{\PYZlt{}=} \PY{o}{|}\PY{n}{jobs}\PY{o}{|}
  \PY{k}{requires} \PY{o}{|}\PY{n}{partialSol}\PY{o}{|} \PY{o}{==} \PY{n}{i} \PY{o}{+} \PY{l+m+mi}{1}
  \PY{k}{requires} \PY{n}{isPartialSol}\PY{p}{(}\PY{n}{partialSol}\PY{p}{,} \PY{n}{jobs}\PY{p}{,} \PY{o}{|}\PY{n}{partialSol}\PY{o}{|}\PY{p}{)}
  \PY{k}{requires} \PY{n}{partialSolutionWithJobI}\PY{p}{(}\PY{n}{partialSol}\PY{p}{,} \PY{n}{jobs}\PY{p}{,} \PY{n}{i}\PY{p}{)}
  \PY{k}{requires} \PY{n}{PartialSolProfit}\PY{p}{(}\PY{n}{partialSol}\PY{p}{,} \PY{n}{jobs}\PY{p}{,} \PY{n}{i}\PY{p}{)} \PY{o}{==} \PY{n}{jobs}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{.}\PY{n}{profit}
  \PY{k}{requires} \PY{k}{forall} \PY{n}{k} \PY{p}{::} \PY{n}{j} \PY{o}{\PYZlt{}} \PY{n}{k} \PY{o}{\PYZlt{}} \PY{n}{i} \PY{o}{==}\PY{o}{\PYZgt{}} \PY{n}{partialSol}\PY{p}{[}\PY{n}{k}\PY{p}{]} \PY{o}{==} \PY{l+m+mi}{0}
  \PY{k}{ensures} \PY{n}{PartialSolProfit}\PY{p}{(}\PY{n}{partialSol}\PY{p}{,} \PY{n}{jobs}\PY{p}{,} \PY{n}{j} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)} \PY{o}{==} \PY{n}{jobs}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{.}\PY{n}{profit}
  \PY{k}{decreases} \PY{n}{i} \PY{o}{\PYZhy{}} \PY{n}{j}
\PY{p}{\PYZob{}}
  \PY{k}{if} \PY{n}{j} \PY{o}{==} \PY{n}{i} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}
  \PY{p}{\PYZob{}}
    \PY{k}{assert} \PY{n}{PartialSolProfit}\PY{p}{(}\PY{n}{partialSol}\PY{p}{,} \PY{n}{jobs}\PY{p}{,} \PY{n}{j} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)} \PY{o}{==} \PY{n}{jobs}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{.}\PY{n}{profit}\PY{p}{;}
  \PY{p}{\PYZcb{}}
  \PY{k}{else}
  \PY{p}{\PYZob{}}
    \PY{n}{ComputeProfitWhenOnly0BetweenJI}\PY{p}{(}\PY{n}{partialSol}\PY{p}{,} \PY{n}{jobs}\PY{p}{,} \PY{n}{i}\PY{p}{,} \PY{n}{j} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{;}
  \PY{p}{\PYZcb{}}

\PY{p}{\PYZcb{}}
\end{Verbatim}


Iată rezumatul întregii dezvoltări:
\begin{table}[h!]
\centering
\begin{tabular}{>{\raggedright}p{7cm} p{3cm}}
    \textbf{Categorie} & \textbf{Număr} \\
    \midrule
    Metode & 7 \\
    Predicate & 21 \\
    Funcții & 2 \\
    Leme & 14 \\
    Precondiții & 148 \\
    Postcondiții & 49 \\
    Invarianți & 46 \\
    Assert-uri & 129 \\
    Comentarii & 155 \\
\end{tabular}
\end{table}

Procesul de dezvoltare a codului a durat aproximativ 7 luni, unde prima lună a fost dedicată introducerii în limbajul de programare Dafny. 
Pe parcurs am învățat foarte multe lucruri noi: începând cu structuri de date din Dafny, ce sunt invarianții, care sunt limitele pentru invarianți, ce sunt metodele, funcțiile și predicatele și continuând până la cum să evit construirea unor metode fragile, cum să folosesc assert-urile și assume-urile încât să-mi dau seama ce nu reușește Dafny să demonstreze. Lemele au fost la început partea puțin mai dificilă, deoarece nu reușeam să le generalizez.


Dacă ar fi ceva de îmbunătățit la Dafny, eu consider că ar fi de mare folos să ofere sugestii, exemple în cazurile în care ceva lipsește sau nu este bine.   

Pe baza acestei lucrări, consider că există oportunități semnificative pentru cercetări viitoare, cum ar fi extinderea tehnicii pentru probleme mai complexe sau adaptarea algoritmului pentru a lucra într-un context paralel sau distribuit. De asemenea, integrarea unor alte limbaje și instrumente de verificare formală ar putea oferi perspective noi și valoroase.

Codul sursă este disponibil la adresa \url{https://github.com/roxana413/Licenta}.

În concluzie, am demonstrat că algoritmul de selecție a activităților poate fi implementat corect folosind programarea dinamică și verificarea formală în Dafny, contribuind astfel la îmbunătățirea metodelor și tehnologiilor utilizate în dezvoltarea de algoritmi siguri și fiabili.